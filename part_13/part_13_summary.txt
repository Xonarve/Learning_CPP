------------------------------
Наследование
Исходный класс - базовый. Наследуемый класс - производный.
Пометка: Constructor::Constructor(const string &fn, const string &ln):
		firstname(fn), lastname(ln).
	Constructor::Construcor(const string &fn, const string &ln) {
		firstname = fn;
		lastname = ln;
	}
В первом случае выполняется инициализация данных членов с помощью соотвествующего конструктора класса string.
Во втором случае сначала вызывается конструктор по умолчанию для string, далее выполняется перегруженная операция
присваивания.
-------------------------------
Порождение класса
class newClass : public BasicClass {
	...
}
Демонстрируется открытое порождение. При открытом порождении открытые члены базового класса становятся открытыми
члнами производного класса. Закрытые порции базового класса становятся частью производного класса, доступ к ним возможен
только через открытые и защищенныые методы базового класса.
------------------------------
Управление доступом protected
Члены под категорией protected являются недоступными для внешнего мира, однако производный класс имеет к ним доступ.
При работе с данными членами рекомендуется использовать защищенный метод. Для доступа из производных классов к
данным-членам базового, рекомендуется использовать методы базового.
Защищенный доступ может быть полезен для функций членов базового класса, к которым необходимо получить доступ из
производного.
------------------------------
Абстрактные базовые классы
Напомним, что полиморфным наследованием называется наследование с переопределением методов производного класса
относительно базового.
Абстрактный базовый класс (АБК) - базовый класс, в который заносятся общие данные-члены и методы, а затем от
данного класса порождаются отдельные производные, дополняющие его своими данными.
Для работы с такими классами можно воспользоваться полиморфизмом (создать массив указатель на АБК) и работать
через них с порожденными объектами.
Чистая виртуальная функция - название функции для представления нереализованной функции. Объявление:
virtual type namefunc() const = 0;
Невозможно создать объект класса, содержащего чистую виртуальную функцию. Смысл класса, использовать его
только как базовый. Настоящий АБК содержит как минимум одну чистую виртуальную фукнцию. Определять такую функцию можно,
но не обязательно.
------------------------------
Философия АБК
При проектировании иерархии наследования классов, конкретными классами должны быть только те, которые не
являются базовыми.
АБК как способ ведения интерфейса. Производный класс должен подчиняться правилам интерфейса, установленным
АБК. Гарантируется что все компоненты, порожденные от АБК поддерживают, как минимум, общие возможности,
установленные АБК.
------------------------------
Наследование и динамическое выделение памяти
Базовый класс работает с динамической памятью:
1. Производный класс не работает с динамической памятью - годяться методы по умолчанию, особые меры не нужны.
2. Производный класс также работает с динамической памятью:
- необходимо определить явный деструктор. Деструктор производного класса выполняет необходимую для него работу
и передает управление деструктору базового класса. Тот в свою очередь завершает очищение оставшихся данных.
- конструктор копирования производного имеет доступ только к данным производного, поэтому он должен вызывать конструктор
базового для обработки части его данных:
Inheritance(const Inheritance& inh) : Base(inh) //конструктору базового класса передается ссылка производного
(полиморфизм).
- операция присваивания. Необходима перегрузка, очевидно. Однако, посколько данный метод является методом базового класса,
необходимо позаботиться о присваивании наследуемой части от базового класса, явно вызвав операцию присваивания,
определенную в базовом классе:
Inheritance& operator=(const Inheritance& inh) {
	if (this == & inh)
		return *this;
	Base::operator=(hs); //копирование базовой части
	...
}

Вопросы:
1. Производный класс наследует от базового данные-члены, функции-члены.