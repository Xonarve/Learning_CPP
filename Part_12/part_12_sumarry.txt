-----------------------------
Статистический член класса

Если в определении класса объявлен статистический член, программа создает лишь одну копию данной переменной для всех объектов класса.

Для статистического члена класса инициализация осуществляется отдельным оператором вне объявления класса.

Оператор инициализации задает тип и указывает область действия данной переменной и название. Инициализация метода описывается в файле методов.
(Если поместить инициализацию в заголовочном файле, там же, где определяется класс, то множественное включение одного и того же
заголовочного файла в другие файлы повлечет за собой ошибочное выполнение инициализации одной и той же переменной несколько раз).
(Константный статистический член класса можно (необходимо) инициализировать при объявлении данного члена. Проблема множественного 
включения не будет распространятся на данный член, так как модификатор const оказывает специфическое воздействие на поведение данного члена).
-----------------------------
Конструкторы по умолчанию

Если для класса не задан никакой конструктор, с++ предоставляет конструктор по умолчанию.

Если для класса определен какой-либо конструктор, то компилятор уже не предоставляет конструктор по умолчанию. 
Таким образом, если определенный прораммистом конструктор не инициализирует все необходимые данные-члены 
или же вручную не определен конструктор по умолчанию, то инициализировать объект неявно не получится.

Конструктор по умолчанию может быть определен лишь один раз. В противном случае это ведет к неоднозначности. 
-----------------------------
Конструкторы копирования

Служит для копирования некоторого объекта в создаваемый объект, то есть используется во время инициализации, а также при передаче функции
аргумента по значению и возврата такого аргумента. Обычно, имеет вид className(const className&).

Конструктор копирования по умолчанию выполняет поверхностное копирование (почленное копирование нестатических членов).
-----------------------------
Конструктор присваивания
Подобно тому, как ANSI C разрешает присваивание структур, C++ допускает присваивание объектов класса.
Это осуществляется за счет автоматической перегрузки операции присваивания, перегрузка выглядит следующим образом:
ClassName &operator=(const ClassName &);
Перегруженная операция присваивания срабатывает присваивании одного объекта другому существующему объекту.
При инициализации объекта, операция присваивания не обязательна.
-----------------------------
Важная пометка!
Если при почленном присваивании в качестве одного из данных членов пристутствует объект, то программа
присваивает данные член одного объекта другому с помощью уже перегруженной операцией
присваивания, определенной для класса данного объекта-члена.
-----------------------------
Перегрузка операции присваивания
При реализации прегрузки операции присваивания для объектов, необходимо учесть следующие факторы:
Функция перегрузки должна возвращать ссылку на объект,
Целевой объект может ссылаться на данные, для которых ранее (например при создании данного объекта)
уже была распределена память, поэтому при наличии такового, в функции перегрузки присваивания необходимо использовать 
операцию  delete[].
Функция должна содержать защиту от присваивания объекта самому себе, по причине реализации предыдущего пункта.
-----------------------------
Примечание:
Создание дружественных функций сравнения (не функции члены класса) облегчают сравнение объектов String и строк в стиле C.
Пометка:
Функция strcmp, принимает два аргумента типа "строка", возвращает положительное значение, если первый аргумент
имеет большее значение чем второй (см. механику сравнения строк - по табличному коду). Возвращает отрицательное
значение, если второй агрумент больше чем первый, возвращает нуль, если оба аргумента равны.
-----------------------------
Перегрузка символа "квадратные скобки для осуществления возможности скобочной нотации".
Перегрузка осуществляется с помощью оператора operator[] (int i), в качестве возвращаемого типа данного оператора
можно задать ссылку на char, тогда это значение будет являться в точности соотвествующим символом исходной строки.
Таким образом, можно получать данные к закрытому члену класса.
Добавление модификаторов const, создавая еще один аналогичный оператор, позволит получить доступ для чтения 
к константным объектам, а также доступ для чтения и записи к обычным объектам.
-----------------------------
Статические функции-члены класса
Функцию член можно объявить как статическую, ключевое слово static должно присутствовать только в объявлении.
Статическая функция член не получает указатель this, ее не обязательно вызывать через объект. Ее можно вызвать
с помощью имени класса и операции разрешения контекста.
Так как статическая функция не связана с каким-либо конкретным объектом, она может работать
только со статическими членами класса.
-----------------------------
Важное замечание:
В классе может имется множество различных конструторов, но деструктор всегда один. Таким образом, все конструкторы
должны единобразно использовать операцию new (со скобками или без). Для указателя, инициализированного в занчение
nullptr (NULL) допустимо использовать оба вида операции delete.
-----------------------------
Возврат ссылки на константный объект
При таком возврате не используется конструктор копирования - производительность, однако при выполнении вызываемой функции,
ссылка должна указывать на существующий объект. Кроме того, возвращаемый тип должен быть константным.
-----------------------------
Указатели на объекты
-Указатель на объект объявляется как обычно,
-Указатель можно инициализировать адресом существующего объекта,
-Указатель можно инициализировать с помощью операции new, создав новый объект,
При инициализации указатели адресом существующего объекта, необходимо проявить дополнительное внимание.
-----------------------------
Использование new с размещением
Использование данной операции в контекте объектов добавляет дополнительные тонкости.
1. Управление позициями в буфере ложиться на программиста (создание и помещение двух объектов в память, в противном случае
они перезапишутся). Для указание правильных позиций можно использовать оператор sizeof().
2. Для удаления объектов, размещенных в заданном блоке памяти, необходимо явно вызвать деструкторы в порядке, обратном
порядку создания. Только после удаления всех объектов в блоке, можно очистить сам блок памяти.
-----------------------------
Вложенные структуры и классы
Структура, класс или перечисление, объявленные внутри класса называются вложенными в класс.
Областью их действия является класс. Такое объявление создает тип, который можно использовать внутри класса.
Если же тип объявлен в разделе public, то пользоваться им можно и вне класса, получая доступ с помощью операции разрешения контекста.
-----------------------------
Список инициализаторов членов
Вызов конструктора создает объект до того как начинает выполнятся его тело.
В С++ есть возможность инициализировать константные данные члены класса.
Кроме того это также необходимо для инициализации данных класса, объявленных как ссылки.
Сделать это нужно в тот момент, когда конструктор уже создан, но до того момента, когда конструктор уже дойдет до тела.
В С++ имеется специальный синтакис - список инициализаторов членов:
Name::Name(type data) : class_data(data);
data может быть также литералом.
Такой синтаксис может применятся только в конструкторах.
Данные члены инициализируется в том порядке, в котором они расположены в класса,
а не в порядке следования инициализаторов.
-----------------------------
Фиктивные методы
Существует способ определения фиктивных методов, для этого их необходимо объявить в закрытом разделе класса.
Таким методы могут переопределить стандартный метод (будь то конструктор копирования или операция присваивания)
а также запретят доступ к своему выполнению для программы.
-----------------------------
Тонкие моменты с конструкторами копирования и операцией присваивания
При инициализации объекта другим (в текущей версии компилятора) всегда используется конструктор копирования.
Члены иницализированного класса будут иметь нулевые указатели. Корректная смена адреса при перегрузке, без утечек памяти.
При присваивании текущему (уже существующему) объекту другого всегда используется операция присваивания.
Для избежания утечек памяти необходимо очистить память указателей членов присваивающего класса.
При иницилизации объекта другими, использующими между собой бинарные операции, всегда создается временный объект,
как автоматически, так и вручную и мы теряем память если при перегрузке необходимо изменить содержания указателей
временного объекта.

